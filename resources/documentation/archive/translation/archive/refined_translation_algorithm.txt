# A More Circumspect NormCode Translation Algorithm

This document outlines a refined algorithm for translating natural language into NormCode, combining insights from practical examples and formal definitions.

### Fundamental NormCode Concepts

Before detailing the algorithm, it's important to understand the basic building blocks of NormCode.

*   **Inference:** The core unit of NormCode. An inference is a single logical step in a plan. It consists of a **function/operation (`<=`)** which defines the operation to be performed, and the **Values (`<-`)** which are the inputs or ingredients for that action.
*   **Concepts:** These are the "words" of NormCode, representing the ideas, data, and actions in the plan. The main types are:
    *   `{}` **Object**: A thing, a variable, or a piece of data (e.g., `{user name}`).
    *   `<>` **Statement**: A statement that can be true or false (e.g., `<the user is an admin>`).
    *   `::()` **Imperative**: A command or an action to be done (e.g., `::(calculate the total)`).
    *   `[]` **Relation**: A group or collection of things (e.g., `[all user emails]`).

This translation algorithm is the process for converting unstructured natural language (`normtext`) into a structured plan composed of these inferences and concepts.

### The Role of Annotations (`?:`, `...:`, `/:`)

These annotations are fundamental to the state management of the decomposition process.

*   `...:` **Source Text Annotation**: Holds the piece of the original `normtext` currently being analyzed. A concept is considered "un-decomposed" as long as it has a `...:` annotation that has not yet been fully parsed.
*   `?:` **Question Annotation**: The question being asked about the concept, derived from the `...:` text.
*   `/:` **Description Annotation**: A human-readable description of the *result* of the decomposition for that concept.

The recursion for a branch is **complete** when the `...:` annotation has been fully consumed and a definitive `/:` annotation has been generated.

### Phase 1: Top-Level Analysis

1.  **Analyze the Source Text's Core Purpose:** Read the entire `normtext` and determine its primary function:
    *   Is it describing a **process** or action? -> Top-level will be an **imperative `::()`**.
    *   Is it defining a **object** or noun? -> Top-level will be an **object `{}`**.
    *   Is it describing a **condition** or statement? -> Top-level will be a **statement `<>`**.

2.  **Formulate the Top-Level Inference:** Based on the purpose, create the normcode draft and attach the entire `normtext` to its `...:` annotation.

### Phase 2: Recursive Decomposition Loop

For every concept in the NormCode draft that has an un-parsed `...:` annotation:

1.  **Ask the Next Question (`?:`):** Read the `...:` text. Formulate the next "main question" (What is it? How is it done? When is it true?) and add it as a `?:` annotation.

2.  **Determine the Next function/operation (`<=`):** Based on the question, select the correct function/operation to structure the answer. This is the core decision point of the decomposition.
    *   **For Grounding Primitive Inputs:** If the concept's definition comes from an external source, use the input function/operation `:>:`. This is a terminal step for the concept, consuming its `...:` and producing a `/:`.
    *   **For Nominalizing Actions:** If the action in the `...:` text is the concept's primary definition, use `$::` to formally declare the imperative `::(...)` as a concept.
    *   **For Other Decompositions:** For all other relationships, select the appropriate function/operation (`$.`, `@if`, `&across`, `@by`, etc.).

3.  **Generate Description and Link Children:** Once the function/operation is chosen, the parent concept's role is to describe the new structure and link to its children.
    *   First, add a `/:` or `...:` annotation to the function/operation that describes what is being done by the function/operation (e.g., "It is done by some method."). 
    *   Next, create the new, lower-level value concepts (`<-`) required by the function/operation according to the normtext and the syntax of the function/operation.
    *   Finally, distribute the parent's original `...:` text among the `...:` annotations of these new child concepts. If a child's task is fully defined by this and needs no further decomposition, it can be given a `/:` directly with simple description.

4.  **Recurse:** The loop continues, now targeting the new child concepts with un-parsed `...:` annotations.

### Detailed Breakdown of Phase 1

This initial step is a detailed analysis of the raw `normtext` and any provided `context`. Its goal is to establish the foundation of the NormCode translation by identifying three key components:

1.  **The Inference Target**: This is the primary subject of a given `normtext`. The process involves asserting the inference target and classifying the core topic into one of two main categories:
    *   **Action-like**: Represents something that is performed or evaluated. This category includes:
        *   **Imperatives (`::()`):** A process, command, or action to be executed (e.g., `::(bake)`).
        *   **Judgements (`::< >`):** An inquiry that evaluates the truth of a statement (e.g., asking if a condition is true).
    *   **Object-like**: Represents a static entity, concept, or the relationship between them. This category includes:
        *   **Subject Declarations (`:<subject>:`):** Defines the primary subject of a block (e.g., :LLM:).
        *   **Statements (`<>`):** An assertion of fact (e.g., `<Kelly is beautiful>`).
        *   **Objects (`{}`):** A single entity or concept (e.g., `{user account}`).
        *   **Relations (`[]`):** Represents the relationship between concepts (e.g., [{position} and {number}]).

2.  **Determining the Question**: This step classifies the user's intent by analyzing the core inquiry. This moves beyond simple keywords to identify the fundamental structure of the question being investigated. The types of problems can be broken down as follows:
    For the **Object-like** category:
    *   **Classification/Specification**: Defining a concept by relating it to another (e.g., "What is a user account?"). Maps to `$.`.
    *   **Identification**: Asserting that a concept is identical to a specific marked instance (e.g., "what is the same number sequence"). Maps to `$=`.
    *   **Nominalization**: Defining a concept as the nominal form of a process (e.g., "What is user authentication?"). Maps to `$::`.
    *   **Instantiation**: Defining a concept by enumerating its members (e.g., "What are all numbers?"). Maps to `$%`.
    *   **Continuation/Extension**: How a concept is formed by adding to an existing one (e.g., "What is the updated sequence?"). Maps to `$+`.
    *   **Ordered Composition**: How a concept is formed by combining others in sequence (e.g., "What is the combination of two number sequences?"). Maps to `&across`.
    *   **Annotated Composition**: How a concept is formed by grouping related data points (e.g., "What is the value with position indexed?"). Maps to `&in`.
    *   **Process Request**: Requesting the execution of a process to find or compute something (e.g., "How do you find the user?"). Maps to `::({})` or `:_:{}({})`.
    *   **Judgement Request**: Requesting an evaluation of a condition or state (e.g., "is a user an admin?"). Maps to `::<{}>` or `::{}({}):`.
    *   **I/O Request**: Requesting external input or describing external output (e.g., "The user name is a primitive input?", "The user name is a final output?"). Maps to `:>:()` or `:<:()`.
    *   **Element-wise Breakdown**: Breaking down a concept into its individual members (e.g., "how to square a sequence by each of its member?"). Maps to `*every`.

    For the **Action-like** category:
    *   **Methodology Declaration**: Describing the means by which an action is performed (e.g., "How do you authenticate?"). Maps to `@by`.
    *   **Conditional Dependency**: Actions depending on a state being true or false (e.g., "When do you show the dashboard?"). Maps to `@if`, `@if!`.
    *   **Sequential Dependency**: Actions that depend on a prior event (e.g., showing a dashboard after authentication). Maps to `@after`.

3.  **The Operator Selection**: This is the crucial decision point. Based on the determined **Inference Target** and **Problem Type**, the algorithm selects the appropriate initial NormCode function/operator (`<=`) that will structure the top-level inference. 
    - See the [normcode_operator_guidance.txt](normcode_operator_guidance.txt) for more details.

In essence, this step serves as the analytical "brain" that interprets the user's request and translates that understanding into the foundational pieces of the NormCode draft.

