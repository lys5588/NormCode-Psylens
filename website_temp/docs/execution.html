<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="NormCode Execution Model - Learn how NormCode plans run at runtime with dependency resolution and checkpointing.">
    <link rel="icon" type="image/png" href="../Psylensai_log_raw.png">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@400;500;600&family=IBM+Plex+Mono:wght@400;500&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="../nav.css">
    <link rel="stylesheet" href="styles.css">
    <title>Execution Model - NormCode è§„èŒƒç </title>
</head>
<body>
    <!-- Navigation will be loaded by load-nav.js -->

    <!-- Page Header -->
    <header class="page-header">
        <h1 data-i18n="page.title">Execution Model</h1>
        <p data-i18n="page.subtitle">How NormCode plans run at runtimeâ€”from compilation to completion.</p>
    </header>

    <!-- Main Content -->
    <main>
        <div class="breadcrumb">
            <a href="../how-it-works.html" data-i18n="nav.docs">Documentation</a>
            <span>â€º</span>
            <span data-i18n="page.title">Execution Model</span>
        </div>

        <!-- Pipeline -->
        <section>
            <h2 data-i18n="section.pipeline">The Compilation Pipeline</h2>
            <p data-i18n="section.pipelineDesc">NormCode plans go through a compilation process from intent to execution:</p>
            
            <div class="code-example">
                <code data-i18n-html="code.pipeline">
<span class="string">Instruction</span> (natural language) or <span class="string">.ncds</span> (draft)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;â†“<br>
<span class="string">Derivation</span> â†’ .ncds<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;â†“<br>
<span class="string">Formalization</span> (Grammar check â†’ .ncd)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;â†“<br>
<span class="string">Post-Formalization</span> (Context + resource demand)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;â†“<br>
<span class="string">Activation</span> (Resolve resources â†’ JSON repos)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;â†“<br>
<span class="keyword">&nbsp;&nbsp;Orchestrator Executes</span>
                </code>
            </div>

            <div class="info-box">
                <p data-i18n="section.pipelineNote"><strong>For most users:</strong> You can start with natural language instruction or write <code class="inline-code">.ncds</code> directly. The compiler produces <code class="inline-code">.concept.json</code> + <code class="inline-code">.inference.json</code> for execution.</p>
            </div>
        </section>

        <!-- Dependency Resolution -->
        <section>
            <h2 data-i18n="section.dependency">Inside-Out, Top-to-Bottom Execution</h2>
            <p data-i18n="section.dependencyDesc">NormCode executes <strong>inside-out</strong> (innermost first) and <strong>top-to-bottom</strong> (sibling order): nested inferences complete before their parents, and siblings execute in declaration order.</p>
            
            <div class="code-example">
                <code data-i18n-html="code.dependency">
<span class="comment">/: Step 3 - Runs last (needs both inputs)</span><br>
&lt;- result<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;= calculate<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">/: Step 1a - Can run immediately</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;- input A<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;= process A<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;- raw A<br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">/: Step 1b - Can run in parallel with 1a</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;- input B<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;= process B<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;- raw B
                </code>
            </div>

            <h3 data-i18n="section.executionOrder">Execution Order</h3>
            <ol>
                <li data-i18n="exec.step1">Inferences for <code class="inline-code">input A</code> and <code class="inline-code">input B</code> are ready immediately (only need raw inputs)</li>
                <li data-i18n="exec.step2">They can run <strong>in parallel</strong> since they don't depend on each other</li>
                <li data-i18n="exec.step3">Once both complete â†’ the <code class="inline-code">calculate</code> inference can run</li>
                <li data-i18n="exec.step4">Result is produced</li>
            </ol>

            <h3 data-i18n="section.readiness">Readiness Criteria</h3>
            <p data-i18n="section.readinessDesc">An inference becomes ready to execute when:</p>
            <ul>
                <li data-i18n="ready.deps">All child inferences are complete (dependencies met)</li>
                <li data-i18n="ready.func">Functional concept is ready (the operation definition exists)</li>
                <li data-i18n="ready.vals">Value concepts are ready (all inputs have data)</li>
            </ul>
        </section>

        <!-- Two Types -->
        <section>
            <h2 data-i18n="section.twoTypes">The Two Types of Execution</h2>
            
            <h3 data-i18n="section.semantic">Semantic Sequences</h3>
            <p data-i18n="section.semanticDesc">Create information through reasoning, generation, or evaluation. <strong>May</strong> use LLM, but can also be optimized to scripts.</p>
            
            <div class="table-wrapper">
                <table>
                    <thead>
                        <tr>
                            <th data-i18n="table.sequence">Sequence</th>
                            <th data-i18n="table.llm">LLM?</th>
                            <th data-i18n="table.cost">Cost</th>
                            <th data-i18n="table.examples">Examples</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong data-i18n="seq.imperative">Imperative</strong></td>
                            <td>âš¡ <span data-i18n="table.maybe">Maybe</span></td>
                            <td data-i18n="table.tokensOrFree">Tokens or Free</td>
                            <td data-i18n="seq.imperativeEx">Extract, generate, transform, analyze</td>
                        </tr>
                        <tr>
                            <td><strong data-i18n="seq.judgement">Judgement</strong></td>
                            <td>âš¡ <span data-i18n="table.maybe">Maybe</span></td>
                            <td data-i18n="table.tokensOrFree">Tokens or Free</td>
                            <td data-i18n="seq.judgementEx">Evaluate, validate, decide, check</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <h3 data-i18n="section.syntactic">Syntactic Sequences (Data Manipulation)</h3>
            <p data-i18n="section.syntacticDesc">Reshape information through deterministic operations. No LLM involved.</p>
            
            <div class="table-wrapper">
                <table>
                    <thead>
                        <tr>
                            <th data-i18n="table.sequence">Sequence</th>
                            <th data-i18n="table.llm">LLM?</th>
                            <th data-i18n="table.cost">Cost</th>
                            <th data-i18n="table.examples">Examples</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong data-i18n="seq.assigning">Assigning</strong></td>
                            <td>âŒ</td>
                            <td data-i18n="table.free">Free</td>
                            <td data-i18n="seq.assigningEx">Select, accumulate, pick first valid</td>
                        </tr>
                        <tr>
                            <td><strong data-i18n="seq.grouping">Grouping</strong></td>
                            <td>âŒ</td>
                            <td data-i18n="table.free">Free</td>
                            <td data-i18n="seq.groupingEx">Collect, combine, bundle items</td>
                        </tr>
                        <tr>
                            <td><strong data-i18n="seq.timing">Timing</strong></td>
                            <td>âŒ</td>
                            <td data-i18n="table.free">Free</td>
                            <td data-i18n="seq.timingEx">Branch, wait, depend on condition</td>
                        </tr>
                        <tr>
                            <td><strong data-i18n="seq.looping">Looping</strong></td>
                            <td>âŒ</td>
                            <td data-i18n="table.free">Free*</td>
                            <td data-i18n="seq.loopingEx">Iterate, repeat for each item</td>
                        </tr>
                    </tbody>
                </table>
            </div>
            
            <p style="font-size: 0.875rem; color: var(--text-muted);" data-i18n="section.loopNote">* The loop structure is free; semantic operations inside the loop cost tokens.</p>
        </section>

        <!-- Orchestrator -->
        <section>
            <h2 data-i18n="section.orchestrator">The Orchestrator</h2>
            <p data-i18n="section.orchestratorDesc">The Orchestrator runs in cycles, managing execution flow:</p>
            
            <div class="code-example">
                <code data-i18n-html="code.orchestrator">
<span class="keyword">FOR EACH CYCLE:</span><br>
&nbsp;&nbsp;1. <span class="function">CHECK</span>&nbsp;&nbsp;&nbsp;â†’ Scan waitlist for ready inferences<br>
&nbsp;&nbsp;2. <span class="function">EXECUTE</span> â†’ Run ready inferences (via AgentFrames)<br>
&nbsp;&nbsp;3. <span class="function">UPDATE</span>&nbsp;&nbsp;â†’ Mark completed, store results<br>
&nbsp;&nbsp;4. <span class="function">REPEAT</span>&nbsp;&nbsp;â†’ Until all inferences complete
                </code>
            </div>

            <h3 data-i18n="section.stateManagement">State Management</h3>
            <div class="table-wrapper">
                <table>
                    <thead>
                        <tr>
                            <th data-i18n="table.component">Component</th>
                            <th data-i18n="table.purpose">Purpose</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Waitlist</strong></td>
                            <td data-i18n="state.waitlist">Static list of all inferences (by flow_index)</td>
                        </tr>
                        <tr>
                            <td><strong>Blackboard</strong></td>
                            <td data-i18n="state.blackboard">Dynamic status tracker (pending/in_progress/completed/skipped)</td>
                        </tr>
                        <tr>
                            <td><strong>ConceptRepo</strong></td>
                            <td data-i18n="state.conceptRepo">Stores data references for all concepts</td>
                        </tr>
                        <tr>
                            <td><strong>InferenceRepo</strong></td>
                            <td data-i18n="state.inferenceRepo">Stores inference definitions and sequences</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </section>

        <!-- Checkpointing -->
        <section>
            <h2 data-i18n="section.checkpointing">Checkpointing & Resuming</h2>
            <p data-i18n="section.checkpointingDesc">The Orchestrator saves complete state to SQLite, enabling powerful workflow control:</p>
            
            <div class="card-grid">
                <div class="card">
                    <span class="card-icon">â¸ï¸</span>
                    <h3 data-i18n="checkpoint.pause">Pause & Resume</h3>
                    <p data-i18n="checkpoint.pauseDesc">Stop execution at any cycle and continue later from exactly where you left off.</p>
                </div>
                <div class="card">
                    <span class="card-icon">ğŸ”€</span>
                    <h3 data-i18n="checkpoint.fork">Fork & Branch</h3>
                    <p data-i18n="checkpoint.forkDesc">Create a new run from any checkpoint to experiment with different approaches.</p>
                </div>
                <div class="card">
                    <span class="card-icon">ğŸ”„</span>
                    <h3 data-i18n="checkpoint.patch">Smart Patching</h3>
                    <p data-i18n="checkpoint.patchDesc">Re-run only changed logic while keeping valid cached results.</p>
                </div>
            </div>

            <h3 data-i18n="section.whatsSaved">What Gets Saved</h3>
            <ul>
                <li data-i18n="saved.metadata">Run metadata (run_id, timestamp, configuration)</li>
                <li data-i18n="saved.snapshots">Full state snapshots at each cycle</li>
                <li data-i18n="saved.blackboard">Blackboard state (status of all concepts/inferences)</li>
                <li data-i18n="saved.references">All concept data references</li>
                <li data-i18n="saved.workspace">Loop iteration workspace</li>
            </ul>
        </section>

        <!-- Flow Index -->
        <section>
            <h2 data-i18n="section.flowIndex">Flow Index System</h2>
            <p data-i18n="section.flowIndexDesc">Every node has a unique flow index that identifies its position in the execution DAG:</p>
            
            <div class="code-example">
                <code data-i18n-html="code.flowIndex">
<span class="string">1</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment"># Root concept (output)</span><br>
â”œâ”€â”€ <span class="string">1.1</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment"># Function concept</span><br>
â”œâ”€â”€ <span class="string">1.2</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment"># First value input</span><br>
â”œâ”€â”€ <span class="string">1.3</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment"># Second value input</span><br>
â”‚&nbsp;&nbsp;&nbsp;â”œâ”€â”€ <span class="string">1.3.1</span>&nbsp;&nbsp;<span class="comment"># Sub-inference function</span><br>
â”‚&nbsp;&nbsp;&nbsp;â”œâ”€â”€ <span class="string">1.3.2</span>&nbsp;&nbsp;<span class="comment"># Sub-inference value</span>
                </code>
            </div>

            <p data-i18n="section.flowIndexUse">Flow indices are used for:</p>
            <ul>
                <li data-i18n="flowUse.id">Node identification in the graph</li>
                <li data-i18n="flowUse.breakpoints">Breakpoint targeting for debugging</li>
                <li data-i18n="flowUse.logs">Log filtering and tracing</li>
                <li data-i18n="flowUse.order">Execution ordering and scheduling</li>
            </ul>
        </section>

        <!-- Canvas App -->
        <section>
            <h2 data-i18n="section.canvasApp">Visual Debugging with Canvas App</h2>
            <p data-i18n="section.canvasAppDesc">The Canvas App provides a visual, interactive environment for executing and debugging NormCode plans:</p>
            
            <div class="card-grid">
                <div class="card">
                    <span class="card-icon">ğŸ“Š</span>
                    <h3 data-i18n="canvas.visualize">Visualize</h3>
                    <p data-i18n="canvas.visualizeDesc">See the entire inference graph before execution.</p>
                </div>
                <div class="card">
                    <span class="card-icon">ğŸ‘ï¸</span>
                    <h3 data-i18n="canvas.watch">Watch</h3>
                    <p data-i18n="canvas.watchDesc">Monitor execution progress in real-time.</p>
                </div>
                <div class="card">
                    <span class="card-icon">ğŸ›</span>
                    <h3 data-i18n="canvas.debug">Debug</h3>
                    <p data-i18n="canvas.debugDesc">Set breakpoints and step through execution.</p>
                </div>
                <div class="card">
                    <span class="card-icon">ğŸ”</span>
                    <h3 data-i18n="canvas.inspect">Inspect</h3>
                    <p data-i18n="canvas.inspectDesc">View tensor data at any node in the graph.</p>
                </div>
            </div>
        </section>

        <!-- Debugging -->
        <section>
            <h2 data-i18n="section.debugging">Debugging Patterns</h2>
            
            <h3 data-i18n="debug.notRunning">Inference not running?</h3>
            <ul>
                <li data-i18n="debug.checkDeps">Check dependencies: Are all child inferences completed?</li>
                <li data-i18n="debug.checkInputs">Check inputs: Are all value concepts ready?</li>
            </ul>

            <h3 data-i18n="debug.wrongResult">Wrong result?</h3>
            <ul>
                <li data-i18n="debug.inspectRefs">Inspect input references: What did the inference actually see?</li>
                <li data-i18n="debug.checkParadigm">Check paradigm configuration: Is the right tool being used?</li>
            </ul>

            <h3 data-i18n="debug.loopNotTerminating">Loop not terminating?</h3>
            <ul>
                <li data-i18n="debug.checkWorkspace">Check Quantifier workspace: Are items being marked as processed?</li>
                <li data-i18n="debug.checkBase">Check loop base reference: Is it empty or has skip values?</li>
            </ul>
        </section>

        <!-- Guarantee -->
        <section>
            <h2 data-i18n="section.guarantee">The Execution Guarantee</h2>
            
            <div class="info-box success">
                <p data-i18n="section.guaranteeText"><strong>NormCode's core promise:</strong> Every inference sees exactlyâ€”and onlyâ€”what you explicitly declare. No hidden context, no state bleeding, full auditability.</p>
            </div>

            <div class="table-wrapper">
                <table>
                    <thead>
                        <tr>
                            <th data-i18n="table.mechanism">Mechanism</th>
                            <th data-i18n="table.enforcement">Enforcement</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td data-i18n="mech.insideOut">Inside-out execution</td>
                            <td data-i18n="mech.insideOutHow">Can't run until inputs ready</td>
                        </tr>
                        <tr>
                            <td data-i18n="mech.refIsolation">Reference isolation</td>
                            <td data-i18n="mech.refIsolationHow">Each concept has its own Reference</td>
                        </tr>
                        <tr>
                            <td data-i18n="mech.explicitRetrieval">Explicit retrieval</td>
                            <td data-i18n="mech.explicitRetrievalHow">Only fetches declared inputs</td>
                        </tr>
                        <tr>
                            <td data-i18n="mech.noGlobal">No global state</td>
                            <td data-i18n="mech.noGlobalHow">No hidden context bleeding</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </section>

        <!-- Navigation -->
        <section style="margin-top: 3rem; padding-top: 2rem; border-top: 1px solid var(--border);">
            <div class="card-grid">
                <a href="compilation.html" class="card-link">
                    <div class="card">
                        <span class="card-icon">ğŸ”„</span>
                        <h3 data-i18n="next.compilation">Next: Compilation</h3>
                        <p data-i18n="next.compilationDesc">The 4-phase pipeline from draft to executable.</p>
                    </div>
                </a>
                <a href="examples.html" class="card-link">
                    <div class="card">
                        <span class="card-icon">ğŸ’¡</span>
                        <h3 data-i18n="nav.examples">See Examples</h3>
                        <p data-i18n="next.examplesDesc">Real-world patterns and complete code samples.</p>
                    </div>
                </a>
            </div>
        </section>

        <a href="../how-it-works.html" class="back-link">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M19 12H5M12 19l-7-7 7-7"/>
            </svg>
            <span data-i18n="nav.backDocs">Back to Documentation</span>
        </a>
    </main>

    <!-- Footer -->
    <footer>
        <p><strong>NormCode è§„èŒƒç </strong> Â· <a href="https://github.com/GEOGUANSIN/normCode" target="_blank">GitHub</a> Â· <a href="https://arxiv.org/abs/2512.10563" target="_blank" data-i18n="footer.paper">Paper</a></p>
    </footer>

    <script src="../load-nav.js"></script>
    <script>
        const translations = {
            en: {
                nav: {
                    companyName: 'Psylens.AI',
                    home: 'Home',
                    docs: 'Documentation',
                    overview: 'Overview',
                    syntax: 'Syntax Reference',
                    execution: 'Execution Model',
                    compilation: 'Compilation',
                    examples: 'Examples',
                    team: 'Team',
                    backDocs: 'Back to Documentation'
                },
                page: {
                    title: 'Execution Model',
                    subtitle: 'How NormCode plans run at runtimeâ€”from compilation to completion.'
                },
                section: {
                    pipeline: 'The Compilation Pipeline',
                    pipelineDesc: 'NormCode plans go through a compilation process from intent to execution:',
                    pipelineNote: '<strong>For most users:</strong> You can start with natural language instruction or write <code class="inline-code">.ncds</code> directly. The compiler produces <code class="inline-code">.concept.json</code> + <code class="inline-code">.inference.json</code> for execution.',
                    dependency: 'Inside-Out, Top-to-Bottom Execution',
                    dependencyDesc: 'NormCode executes <strong>inside-out</strong> (innermost first) and <strong>top-to-bottom</strong> (sibling order): nested inferences complete before their parents, and siblings execute in declaration order.',
                    executionOrder: 'Execution Order',
                    readiness: 'Readiness Criteria',
                    readinessDesc: 'An inference becomes ready to execute when:',
                    twoTypes: 'The Two Types of Execution',
                    semantic: 'Semantic Sequences',
                    semanticDesc: 'Create information through reasoning, generation, or evaluation. <strong>May</strong> use LLM, but can also be optimized to scripts.',
                    syntactic: 'Syntactic Sequences (Data Manipulation)',
                    syntacticDesc: 'Reshape information through deterministic operations. No LLM involved.',
                    loopNote: '* The loop structure is free; semantic operations inside the loop may cost tokens if using LLM.',
                    orchestrator: 'The Orchestrator',
                    orchestratorDesc: 'The Orchestrator runs in cycles, managing execution flow:',
                    stateManagement: 'State Management',
                    checkpointing: 'Checkpointing & Resuming',
                    checkpointingDesc: 'The Orchestrator saves complete state to SQLite, enabling powerful workflow control:',
                    whatsSaved: 'What Gets Saved',
                    flowIndex: 'Flow Index System',
                    flowIndexDesc: 'Every node has a unique flow index that identifies its position in the execution DAG:',
                    flowIndexUse: 'Flow indices are used for:',
                    canvasApp: 'Visual Debugging with Canvas App',
                    canvasAppDesc: 'The Canvas App provides a visual, interactive environment for executing and debugging NormCode plans:',
                    debugging: 'Debugging Patterns',
                    guarantee: 'The Execution Guarantee',
                    guaranteeText: '<strong>NormCode\'s core promise:</strong> Every inference sees exactlyâ€”and onlyâ€”what you explicitly declare. No hidden context, no state bleeding, full auditability.'
                },
                exec: {
                    step1: 'Inferences for input A and input B are ready immediately (only need raw inputs)',
                    step2: 'They can run <strong>in parallel</strong> since they don\'t depend on each other',
                    step3: 'Once both complete â†’ the calculate inference can run',
                    step4: 'Result is produced'
                },
                ready: {
                    deps: 'All child inferences are complete (dependencies met)',
                    func: 'Functional concept is ready (the operation definition exists)',
                    vals: 'Value concepts are ready (all inputs have data)'
                },
                table: {
                    sequence: 'Sequence',
                    llm: 'LLM?',
                    cost: 'Cost',
                    examples: 'Examples',
                    tokens: 'Tokens',
                    tokensOrFree: 'Tokens or Free',
                    maybe: 'Maybe',
                    free: 'Free',
                    component: 'Component',
                    purpose: 'Purpose',
                    mechanism: 'Mechanism',
                    enforcement: 'Enforcement'
                },
                seq: {
                    imperative: 'Imperative',
                    imperativeEx: 'Extract, generate, transform, analyze',
                    judgement: 'Judgement',
                    judgementEx: 'Evaluate, validate, decide, check',
                    assigning: 'Assigning',
                    assigningEx: 'Select, accumulate, pick first valid',
                    grouping: 'Grouping',
                    groupingEx: 'Collect, combine, bundle items',
                    timing: 'Timing',
                    timingEx: 'Branch, wait, depend on condition',
                    looping: 'Looping',
                    loopingEx: 'Iterate, repeat for each item'
                },
                state: {
                    waitlist: 'Static list of all inferences (by flow_index)',
                    blackboard: 'Dynamic status tracker (pending/in_progress/completed/skipped)',
                    conceptRepo: 'Stores data references for all concepts',
                    inferenceRepo: 'Stores inference definitions and sequences'
                },
                checkpoint: {
                    pause: 'Pause & Resume',
                    pauseDesc: 'Stop execution at any cycle and continue later from exactly where you left off.',
                    fork: 'Fork & Branch',
                    forkDesc: 'Create a new run from any checkpoint to experiment with different approaches.',
                    patch: 'Smart Patching',
                    patchDesc: 'Re-run only changed logic while keeping valid cached results.'
                },
                saved: {
                    metadata: 'Run metadata (run_id, timestamp, configuration)',
                    snapshots: 'Full state snapshots at each cycle',
                    blackboard: 'Blackboard state (status of all concepts/inferences)',
                    references: 'All concept data references',
                    workspace: 'Loop iteration workspace'
                },
                flowUse: {
                    id: 'Node identification in the graph',
                    breakpoints: 'Breakpoint targeting for debugging',
                    logs: 'Log filtering and tracing',
                    order: 'Execution ordering and scheduling'
                },
                canvas: {
                    visualize: 'Visualize',
                    visualizeDesc: 'See the entire inference graph before execution.',
                    watch: 'Watch',
                    watchDesc: 'Monitor execution progress in real-time.',
                    debug: 'Debug',
                    debugDesc: 'Set breakpoints and step through execution.',
                    inspect: 'Inspect',
                    inspectDesc: 'View tensor data at any node in the graph.'
                },
                debug: {
                    notRunning: 'Inference not running?',
                    checkDeps: 'Check dependencies: Are all child inferences completed?',
                    checkInputs: 'Check inputs: Are all value concepts ready?',
                    wrongResult: 'Wrong result?',
                    inspectRefs: 'Inspect input references: What did the inference actually see?',
                    checkParadigm: 'Check paradigm configuration: Is the right tool being used?',
                    loopNotTerminating: 'Loop not terminating?',
                    checkWorkspace: 'Check Quantifier workspace: Are items being marked as processed?',
                    checkBase: 'Check loop base reference: Is it empty or has skip values?'
                },
                mech: {
                    insideOut: 'Inside-out execution',
                    insideOutHow: 'Can\'t run until inputs ready',
                    refIsolation: 'Reference isolation',
                    refIsolationHow: 'Each concept has its own Reference',
                    explicitRetrieval: 'Explicit retrieval',
                    explicitRetrievalHow: 'Only fetches declared inputs',
                    noGlobal: 'No global state',
                    noGlobalHow: 'No hidden context bleeding'
                },
                prev: {
                    examples: 'Previous: Examples',
                    examplesDesc: 'Real-world patterns and complete code samples.'
                },
                code: {
                    pipeline: '<span class="string">Instruction</span> (natural language) or <span class="string">.ncds</span> (draft)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;â†“<br><span class="string">Derivation</span> â†’ .ncds<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;â†“<br><span class="string">Formalization</span> (Grammar check â†’ .ncd)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;â†“<br><span class="string">Post-Formalization</span> (Context + resource demand)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;â†“<br><span class="string">Activation</span> (Resolve resources â†’ JSON repos)<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;â†“<br><span class="keyword">&nbsp;&nbsp;Orchestrator Executes</span>',
                    dependency: '<span class="comment">/: Step 3 - Runs last (needs both inputs)</span><br>&lt;- result<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;= calculate<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">/: Step 1a - Can run immediately</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;- input A<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;= process A<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;- raw A<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">/: Step 1b - Can run in parallel with 1a</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;- input B<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;= process B<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;- raw B',
                    orchestrator: '<span class="keyword">FOR EACH CYCLE:</span><br>&nbsp;&nbsp;1. <span class="function">CHECK</span>&nbsp;&nbsp;&nbsp;â†’ Scan waitlist for ready inferences<br>&nbsp;&nbsp;2. <span class="function">EXECUTE</span> â†’ Run ready inferences (via AgentFrames)<br>&nbsp;&nbsp;3. <span class="function">UPDATE</span>&nbsp;&nbsp;â†’ Mark completed, store results<br>&nbsp;&nbsp;4. <span class="function">REPEAT</span>&nbsp;&nbsp;â†’ Until all inferences complete',
                    flowIndex: '<span class="string">1</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment"># Root concept (output)</span><br>â”œâ”€â”€ <span class="string">1.1</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment"># Function concept</span><br>â”œâ”€â”€ <span class="string">1.2</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment"># First value input</span><br>â”œâ”€â”€ <span class="string">1.3</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment"># Second value input</span><br>â”‚&nbsp;&nbsp;&nbsp;â”œâ”€â”€ <span class="string">1.3.1</span>&nbsp;&nbsp;<span class="comment"># Sub-inference function</span><br>â”‚&nbsp;&nbsp;&nbsp;â”œâ”€â”€ <span class="string">1.3.2</span>&nbsp;&nbsp;<span class="comment"># Sub-inference value</span>'
                },
                footer: {
                    paper: 'Paper'
                }
            },
            zh: {
                nav: {
                    companyName: 'å¿ƒé•œæ™º',
                    home: 'é¦–é¡µ',
                    docs: 'æ–‡æ¡£',
                    overview: 'æ¦‚è¿°',
                    syntax: 'è¯­æ³•å‚è€ƒ',
                    execution: 'æ‰§è¡Œæ¨¡å‹',
                    compilation: 'ç¼–è¯‘æµç¨‹',
                    examples: 'ç¤ºä¾‹',
                    team: 'å›¢é˜Ÿ',
                    backDocs: 'è¿”å›æ–‡æ¡£'
                },
                page: {
                    title: 'æ‰§è¡Œæ¨¡å‹',
                    subtitle: 'NormCodeè®¡åˆ’å¦‚ä½•åœ¨è¿è¡Œæ—¶æ‰§è¡Œâ€”â€”ä»ç¼–è¯‘åˆ°å®Œæˆã€‚'
                },
                section: {
                    pipeline: 'ç¼–è¯‘æµæ°´çº¿',
                    pipelineDesc: 'NormCodeè®¡åˆ’ç»å†ä»æ„å›¾åˆ°æ‰§è¡Œçš„ç¼–è¯‘è¿‡ç¨‹ï¼š',
                    pipelineNote: '<strong>å¯¹äºå¤§å¤šæ•°ç”¨æˆ·ï¼š</strong>æ‚¨å¯ä»¥ä»è‡ªç„¶è¯­è¨€æŒ‡ä»¤å¼€å§‹ï¼Œæˆ–ç›´æ¥ç¼–å†™<code class="inline-code">.ncds</code>ã€‚ç¼–è¯‘å™¨ç”Ÿæˆ<code class="inline-code">.concept.json</code> + <code class="inline-code">.inference.json</code>ç”¨äºæ‰§è¡Œã€‚',
                    dependency: 'ç”±å†…å‘å¤–ã€è‡ªä¸Šè€Œä¸‹æ‰§è¡Œ',
                    dependencyDesc: 'NormCode<strong>ç”±å†…å‘å¤–</strong>ï¼ˆæœ€å†…å±‚ä¼˜å…ˆï¼‰å’Œ<strong>è‡ªä¸Šè€Œä¸‹</strong>ï¼ˆåŒçº§é¡ºåºï¼‰æ‰§è¡Œï¼šåµŒå¥—æ¨ç†åœ¨çˆ¶æ¨ç†ä¹‹å‰å®Œæˆï¼ŒåŒçº§æŒ‰å£°æ˜é¡ºåºæ‰§è¡Œã€‚',
                    executionOrder: 'æ‰§è¡Œé¡ºåº',
                    readiness: 'å°±ç»ªæ¡ä»¶',
                    readinessDesc: 'æ¨ç†åœ¨ä»¥ä¸‹æƒ…å†µä¸‹å‡†å¤‡å¥½æ‰§è¡Œï¼š',
                    twoTypes: 'ä¸¤ç§æ‰§è¡Œç±»å‹',
                    semantic: 'è¯­ä¹‰åºåˆ—',
                    semanticDesc: 'é€šè¿‡æ¨ç†ã€ç”Ÿæˆæˆ–è¯„ä¼°åˆ›å»ºä¿¡æ¯ã€‚<strong>å¯èƒ½</strong>ä½¿ç”¨LLMï¼Œä½†ä¹Ÿå¯ä»¥ä¼˜åŒ–ä¸ºè„šæœ¬ã€‚',
                    syntactic: 'è¯­æ³•åºåˆ—ï¼ˆæ•°æ®æ“ä½œï¼‰',
                    syntacticDesc: 'é€šè¿‡ç¡®å®šæ€§æ“ä½œé‡å¡‘ä¿¡æ¯ã€‚ä¸æ¶‰åŠLLMã€‚',
                    loopNote: '* å¾ªç¯ç»“æ„æ˜¯å…è´¹çš„ï¼›å¾ªç¯å†…çš„è¯­ä¹‰æ“ä½œå¦‚æœä½¿ç”¨LLMå¯èƒ½æ¶ˆè€—tokenã€‚',
                    orchestrator: 'ç¼–æ’å™¨',
                    orchestratorDesc: 'ç¼–æ’å™¨ä»¥å‘¨æœŸè¿è¡Œï¼Œç®¡ç†æ‰§è¡Œæµç¨‹ï¼š',
                    stateManagement: 'çŠ¶æ€ç®¡ç†',
                    checkpointing: 'æ£€æŸ¥ç‚¹å’Œæ¢å¤',
                    checkpointingDesc: 'ç¼–æ’å™¨å°†å®Œæ•´çŠ¶æ€ä¿å­˜åˆ°SQLiteï¼Œå®ç°å¼ºå¤§çš„å·¥ä½œæµæ§åˆ¶ï¼š',
                    whatsSaved: 'ä¿å­˜çš„å†…å®¹',
                    flowIndex: 'æµç¨‹ç´¢å¼•ç³»ç»Ÿ',
                    flowIndexDesc: 'æ¯ä¸ªèŠ‚ç‚¹éƒ½æœ‰ä¸€ä¸ªå”¯ä¸€çš„æµç¨‹ç´¢å¼•ï¼Œæ ‡è¯†å…¶åœ¨æ‰§è¡ŒDAGä¸­çš„ä½ç½®ï¼š',
                    flowIndexUse: 'æµç¨‹ç´¢å¼•ç”¨äºï¼š',
                    canvasApp: 'ä½¿ç”¨Canvas Appè¿›è¡Œå¯è§†åŒ–è°ƒè¯•',
                    canvasAppDesc: 'Canvas Appæä¾›äº†ä¸€ä¸ªå¯è§†åŒ–ã€äº¤äº’å¼ç¯å¢ƒï¼Œç”¨äºæ‰§è¡Œå’Œè°ƒè¯•NormCodeè®¡åˆ’ï¼š',
                    debugging: 'è°ƒè¯•æ¨¡å¼',
                    guarantee: 'æ‰§è¡Œä¿è¯',
                    guaranteeText: '<strong>NormCodeçš„æ ¸å¿ƒæ‰¿è¯ºï¼š</strong>æ¯ä¸ªæ¨ç†éƒ½åªèƒ½çœ‹åˆ°æ‚¨æ˜ç¡®å£°æ˜çš„å†…å®¹â€”â€”ä»…æ­¤è€Œå·²ã€‚æ²¡æœ‰éšè—ä¸Šä¸‹æ–‡ï¼Œæ²¡æœ‰çŠ¶æ€æ³„æ¼ï¼Œå®Œå…¨å¯å®¡è®¡ã€‚'
                },
                exec: {
                    step1: 'è¾“å…¥Aå’Œè¾“å…¥Bçš„æ¨ç†ç«‹å³å‡†å¤‡å°±ç»ªï¼ˆåªéœ€è¦åŸå§‹è¾“å…¥ï¼‰',
                    step2: 'å®ƒä»¬å¯ä»¥<strong>å¹¶è¡Œ</strong>è¿è¡Œï¼Œå› ä¸ºå®ƒä»¬ä¸ç›¸äº’ä¾èµ–',
                    step3: 'ä¸¤è€…éƒ½å®Œæˆå â†’ è®¡ç®—æ¨ç†å¯ä»¥è¿è¡Œ',
                    step4: 'äº§ç”Ÿç»“æœ'
                },
                ready: {
                    deps: 'æ‰€æœ‰å­æ¨ç†å·²å®Œæˆï¼ˆä¾èµ–å·²æ»¡è¶³ï¼‰',
                    func: 'åŠŸèƒ½æ¦‚å¿µå‡†å¤‡å°±ç»ªï¼ˆæ“ä½œå®šä¹‰å­˜åœ¨ï¼‰',
                    vals: 'å€¼æ¦‚å¿µå‡†å¤‡å°±ç»ªï¼ˆæ‰€æœ‰è¾“å…¥éƒ½æœ‰æ•°æ®ï¼‰'
                },
                table: {
                    sequence: 'åºåˆ—',
                    llm: 'LLMï¼Ÿ',
                    cost: 'æˆæœ¬',
                    examples: 'ç¤ºä¾‹',
                    tokens: 'Token',
                    tokensOrFree: 'Tokenæˆ–å…è´¹',
                    maybe: 'å¯èƒ½',
                    free: 'å…è´¹',
                    component: 'ç»„ä»¶',
                    purpose: 'ç”¨é€”',
                    mechanism: 'æœºåˆ¶',
                    enforcement: 'æ‰§è¡Œæ–¹å¼'
                },
                seq: {
                    imperative: 'ç¥ˆä½¿å¼',
                    imperativeEx: 'æå–ã€ç”Ÿæˆã€è½¬æ¢ã€åˆ†æ',
                    judgement: 'åˆ¤æ–­',
                    judgementEx: 'è¯„ä¼°ã€éªŒè¯ã€å†³å®šã€æ£€æŸ¥',
                    assigning: 'èµ‹å€¼',
                    assigningEx: 'é€‰æ‹©ã€ç´¯ç§¯ã€é€‰å–ç¬¬ä¸€ä¸ªæœ‰æ•ˆå€¼',
                    grouping: 'åˆ†ç»„',
                    groupingEx: 'æ”¶é›†ã€ç»„åˆã€æ‰“åŒ…é¡¹ç›®',
                    timing: 'æ—¶åº',
                    timingEx: 'åˆ†æ”¯ã€ç­‰å¾…ã€ä¾èµ–æ¡ä»¶',
                    looping: 'å¾ªç¯',
                    loopingEx: 'è¿­ä»£ã€å¯¹æ¯ä¸ªé¡¹ç›®é‡å¤'
                },
                state: {
                    waitlist: 'æ‰€æœ‰æ¨ç†çš„é™æ€åˆ—è¡¨ï¼ˆæŒ‰flow_indexï¼‰',
                    blackboard: 'åŠ¨æ€çŠ¶æ€è·Ÿè¸ªå™¨ï¼ˆpending/in_progress/completed/skippedï¼‰',
                    conceptRepo: 'å­˜å‚¨æ‰€æœ‰æ¦‚å¿µçš„æ•°æ®å¼•ç”¨',
                    inferenceRepo: 'å­˜å‚¨æ¨ç†å®šä¹‰å’Œåºåˆ—'
                },
                checkpoint: {
                    pause: 'æš‚åœå’Œæ¢å¤',
                    pauseDesc: 'åœ¨ä»»ä½•å‘¨æœŸåœæ­¢æ‰§è¡Œï¼Œç¨åä»ä¸­æ–­å¤„ç»§ç»­ã€‚',
                    fork: 'åˆ†å‰å’Œåˆ†æ”¯',
                    forkDesc: 'ä»ä»»ä½•æ£€æŸ¥ç‚¹åˆ›å»ºæ–°è¿è¡Œï¼Œå°è¯•ä¸åŒæ–¹æ³•ã€‚',
                    patch: 'æ™ºèƒ½è¡¥ä¸',
                    patchDesc: 'ä»…é‡æ–°è¿è¡Œæ›´æ”¹çš„é€»è¾‘ï¼ŒåŒæ—¶ä¿ç•™æœ‰æ•ˆçš„ç¼“å­˜ç»“æœã€‚'
                },
                saved: {
                    metadata: 'è¿è¡Œå…ƒæ•°æ®ï¼ˆrun_idã€æ—¶é—´æˆ³ã€é…ç½®ï¼‰',
                    snapshots: 'æ¯ä¸ªå‘¨æœŸçš„å®Œæ•´çŠ¶æ€å¿«ç…§',
                    blackboard: 'é»‘æ¿çŠ¶æ€ï¼ˆæ‰€æœ‰æ¦‚å¿µ/æ¨ç†çš„çŠ¶æ€ï¼‰',
                    references: 'æ‰€æœ‰æ¦‚å¿µæ•°æ®å¼•ç”¨',
                    workspace: 'å¾ªç¯è¿­ä»£å·¥ä½œåŒº'
                },
                flowUse: {
                    id: 'å›¾ä¸­çš„èŠ‚ç‚¹æ ‡è¯†',
                    breakpoints: 'è°ƒè¯•æ–­ç‚¹ç›®æ ‡',
                    logs: 'æ—¥å¿—è¿‡æ»¤å’Œè·Ÿè¸ª',
                    order: 'æ‰§è¡Œé¡ºåºå’Œè°ƒåº¦'
                },
                canvas: {
                    visualize: 'å¯è§†åŒ–',
                    visualizeDesc: 'åœ¨æ‰§è¡Œå‰æŸ¥çœ‹æ•´ä¸ªæ¨ç†å›¾ã€‚',
                    watch: 'ç›‘æ§',
                    watchDesc: 'å®æ—¶ç›‘æ§æ‰§è¡Œè¿›åº¦ã€‚',
                    debug: 'è°ƒè¯•',
                    debugDesc: 'è®¾ç½®æ–­ç‚¹å¹¶é€æ­¥æ‰§è¡Œã€‚',
                    inspect: 'æ£€æŸ¥',
                    inspectDesc: 'æŸ¥çœ‹å›¾ä¸­ä»»ä½•èŠ‚ç‚¹çš„å¼ é‡æ•°æ®ã€‚'
                },
                debug: {
                    notRunning: 'æ¨ç†æ²¡æœ‰è¿è¡Œï¼Ÿ',
                    checkDeps: 'æ£€æŸ¥ä¾èµ–ï¼šæ‰€æœ‰å­æ¨ç†éƒ½å®Œæˆäº†å—ï¼Ÿ',
                    checkInputs: 'æ£€æŸ¥è¾“å…¥ï¼šæ‰€æœ‰å€¼æ¦‚å¿µéƒ½å‡†å¤‡å¥½äº†å—ï¼Ÿ',
                    wrongResult: 'ç»“æœé”™è¯¯ï¼Ÿ',
                    inspectRefs: 'æ£€æŸ¥è¾“å…¥å¼•ç”¨ï¼šæ¨ç†å®é™…çœ‹åˆ°äº†ä»€ä¹ˆï¼Ÿ',
                    checkParadigm: 'æ£€æŸ¥èŒƒå¼é…ç½®ï¼šä½¿ç”¨äº†æ­£ç¡®çš„å·¥å…·å—ï¼Ÿ',
                    loopNotTerminating: 'å¾ªç¯æ²¡æœ‰ç»ˆæ­¢ï¼Ÿ',
                    checkWorkspace: 'æ£€æŸ¥é‡è¯å·¥ä½œåŒºï¼šé¡¹ç›®æ˜¯å¦è¢«æ ‡è®°ä¸ºå·²å¤„ç†ï¼Ÿ',
                    checkBase: 'æ£€æŸ¥å¾ªç¯åŸºç¡€å¼•ç”¨ï¼šæ˜¯å¦ä¸ºç©ºæˆ–æœ‰è·³è¿‡å€¼ï¼Ÿ'
                },
                mech: {
                    insideOut: 'ç”±å†…å‘å¤–æ‰§è¡Œ',
                    insideOutHow: 'è¾“å…¥å‡†å¤‡å¥½åæ‰èƒ½è¿è¡Œ',
                    refIsolation: 'å¼•ç”¨éš”ç¦»',
                    refIsolationHow: 'æ¯ä¸ªæ¦‚å¿µéƒ½æœ‰è‡ªå·±çš„å¼•ç”¨',
                    explicitRetrieval: 'æ˜¾å¼æ£€ç´¢',
                    explicitRetrievalHow: 'åªè·å–å£°æ˜çš„è¾“å…¥',
                    noGlobal: 'æ— å…¨å±€çŠ¶æ€',
                    noGlobalHow: 'æ— éšè—ä¸Šä¸‹æ–‡æ³„æ¼'
                },
                prev: {
                    examples: 'ä¸Šä¸€æ­¥ï¼šç¤ºä¾‹',
                    examplesDesc: 'çœŸå®ä¸–ç•Œçš„æ¨¡å¼å’Œå®Œæ•´ä»£ç ç¤ºä¾‹ã€‚'
                },
                code: {
                    pipeline: '<span class="string">æŒ‡ä»¤</span>ï¼ˆè‡ªç„¶è¯­è¨€ï¼‰æˆ– <span class="string">.ncds</span>ï¼ˆè‰ç¨¿ï¼‰<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;â†“<br><span class="string">æ¨å¯¼</span> â†’ .ncds<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;â†“<br><span class="string">å½¢å¼åŒ–</span>ï¼ˆè¯­æ³•æ£€æŸ¥ â†’ .ncdï¼‰<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;â†“<br><span class="string">åå½¢å¼åŒ–</span>ï¼ˆä¸Šä¸‹æ–‡ + èµ„æºéœ€æ±‚ï¼‰<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;â†“<br><span class="string">æ¿€æ´»</span>ï¼ˆè§£æèµ„æº â†’ JSONå­˜å‚¨åº“ï¼‰<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;â†“<br><span class="keyword">&nbsp;&nbsp;ç¼–æ’å™¨æ‰§è¡Œ</span>',
                    dependency: '<span class="comment">/: æ­¥éª¤3 - æœ€åè¿è¡Œï¼ˆéœ€è¦ä¸¤ä¸ªè¾“å…¥ï¼‰</span><br>&lt;- ç»“æœ<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;= è®¡ç®—<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">/: æ­¥éª¤1a - å¯ä»¥ç«‹å³è¿è¡Œ</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;- è¾“å…¥A<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;= å¤„ç†A<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;- åŸå§‹A<br>&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">/: æ­¥éª¤1b - å¯ä»¥ä¸1aå¹¶è¡Œè¿è¡Œ</span><br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;- è¾“å…¥B<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;= å¤„ç†B<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;- åŸå§‹B',
                    orchestrator: '<span class="keyword">æ¯ä¸ªå‘¨æœŸï¼š</span><br>&nbsp;&nbsp;1. <span class="function">æ£€æŸ¥</span>&nbsp;&nbsp;&nbsp;â†’ æ‰«æç­‰å¾…åˆ—è¡¨ä¸­å°±ç»ªçš„æ¨ç†<br>&nbsp;&nbsp;2. <span class="function">æ‰§è¡Œ</span>&nbsp;&nbsp;&nbsp;â†’ è¿è¡Œå°±ç»ªçš„æ¨ç†ï¼ˆé€šè¿‡AgentFramesï¼‰<br>&nbsp;&nbsp;3. <span class="function">æ›´æ–°</span>&nbsp;&nbsp;&nbsp;â†’ æ ‡è®°å®Œæˆï¼Œå­˜å‚¨ç»“æœ<br>&nbsp;&nbsp;4. <span class="function">é‡å¤</span>&nbsp;&nbsp;&nbsp;â†’ ç›´åˆ°æ‰€æœ‰æ¨ç†å®Œæˆ',
                    flowIndex: '<span class="string">1</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment"># æ ¹æ¦‚å¿µï¼ˆè¾“å‡ºï¼‰</span><br>â”œâ”€â”€ <span class="string">1.1</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment"># åŠŸèƒ½æ¦‚å¿µ</span><br>â”œâ”€â”€ <span class="string">1.2</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment"># ç¬¬ä¸€ä¸ªå€¼è¾“å…¥</span><br>â”œâ”€â”€ <span class="string">1.3</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment"># ç¬¬äºŒä¸ªå€¼è¾“å…¥</span><br>â”‚&nbsp;&nbsp;&nbsp;â”œâ”€â”€ <span class="string">1.3.1</span>&nbsp;&nbsp;<span class="comment"># å­æ¨ç†åŠŸèƒ½</span><br>â”‚&nbsp;&nbsp;&nbsp;â”œâ”€â”€ <span class="string">1.3.2</span>&nbsp;&nbsp;<span class="comment"># å­æ¨ç†å€¼</span>'
                },
                footer: {
                    paper: 'è®ºæ–‡'
                }
            }
        };

        let currentLang = localStorage.getItem('lang') || 'en';

        // Expose setLanguage globally so load-nav.js can call it
        window.setLanguage = function(lang) {
            currentLang = lang;
            localStorage.setItem('lang', lang);
            document.documentElement.lang = lang;
            
            document.querySelectorAll('[data-i18n]').forEach(el => {
                const key = el.getAttribute('data-i18n');
                const keys = key.split('.');
                let value = translations[lang];
                
                for (const k of keys) {
                    value = value?.[k];
                }
                
                if (value !== undefined) {
                    if (value.includes('<code') || value.includes('<strong')) {
                        el.innerHTML = value;
                    } else {
                        el.textContent = value;
                    }
                }
            });

            // Handle HTML translations (for code examples)
            document.querySelectorAll('[data-i18n-html]').forEach(el => {
                const key = el.getAttribute('data-i18n-html');
                const keys = key.split('.');
                let value = translations[lang];
                
                for (const k of keys) {
                    value = value?.[k];
                }
                
                if (value !== undefined) {
                    el.innerHTML = value;
                }
            });

            document.querySelectorAll('.lang-btn').forEach(btn => {
                btn.classList.toggle('active', btn.getAttribute('data-lang') === lang);
            });
        };
        
        setLanguage(currentLang);

        document.querySelectorAll('.lang-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                setLanguage(btn.getAttribute('data-lang'));
            });
        });

        // Mobile menu is handled by load-nav.js
    </script>
</body>
</html>

