<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="How NormCode Works - Learn how NormCode makes data flow explicit and isolated for auditable AI workflows.">
    <link rel="icon" type="image/png" href="Psylensai_log_raw.png">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@400;500;600&family=IBM+Plex+Mono:wght@400;500&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="nav.css">
    <link rel="stylesheet" href="docs/styles.css">
    <title>How It Works - NormCode è§„èŒƒç </title>
</head>
<body>
    <!-- Navigation will be loaded by load-nav.js -->

    <!-- Page Header -->
    <header class="page-header">
        <h1 data-i18n="page.title">How NormCode Works</h1>
        <p data-i18n="page.subtitle">A language for structured AI plans that enforce data isolation by design.</p>
    </header>

    <!-- Main Content -->
    <main>
        <!-- Quick Overview -->
        <section>
            <h2 data-i18n="section.overview">What Problem Does It Solve?</h2>
            <p data-i18n="section.overviewDesc">When you chain multiple LLM calls together, context pollution causes failures. By step 4, the model has 50 pages of documents, raw database results, and extraction metadata all swimming in context. It hallucinates because it's drowning in noise.</p>
            
            <div class="info-box">
                <p data-i18n="section.solution"><strong>The NormCode solution:</strong> Each step is a sealed room. It only sees what you explicitly pass in. No hidden context, no accidental leakage. When something goes wrong, you can see exactly what that step received.</p>
            </div>
        </section>

        <!-- Core Example -->
        <section>
            <h2 data-i18n="section.example">Example: Document Analysis Pipeline</h2>
            <p data-i18n="section.exampleDesc">NormCode uses indentation to show data dependencies. Each step only receives what is explicitly passed to it.</p>
            
            <div class="code-example">
                <code data-i18n-html="code.documentPipeline">
&lt;- executive summary<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;= generate summary from flagged items<br>
&nbsp;&nbsp;&nbsp;&nbsp;&lt;- discrepancy flags<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;= check for mismatches<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;- extracted figures<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;= extract financial data<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;- raw document<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;- database results
                </code>
            </div>
            
            <div class="info-box">
                <p data-i18n="section.readingNote">
                    <strong>Reading bottom-up:</strong> The extraction step sees only <code class="inline-code">raw document</code>. 
                    The mismatch check sees <code class="inline-code">extracted figures</code> + <code class="inline-code">database results</code>. 
                    The summary step sees only <code class="inline-code">discrepancy flags</code>â€”never the full document.
                </p>
            </div>
        </section>

        <!-- Semantic vs Syntactic -->
        <section>
            <h2 data-i18n="section.stepsTitle">Semantic vs. Syntactic Steps</h2>
            <p data-i18n="section.stepsDesc">NormCode distinguishes between two types of operations. Semantic steps <em>may</em> call an LLM, but many can be optimized to use scripts insteadâ€”syntactic steps are always free, instant, and deterministic.</p>
            
            <div class="table-wrapper">
                <table>
                    <thead>
                        <tr>
                            <th data-i18n="table.type">Type</th>
                            <th data-i18n="table.llm">LLM?</th>
                            <th data-i18n="table.cost">Cost</th>
                            <th data-i18n="table.determinism">Determinism</th>
                            <th data-i18n="table.examples">Examples</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong data-i18n="table.semantic">Semantic</strong></td>
                            <td data-i18n="table.maybe">âš¡ Maybe</td>
                            <td data-i18n="table.tokens">Tokens or Free</td>
                            <td data-i18n="table.nonDeterministic">Varies</td>
                            <td data-i18n="table.semanticExamples">Reasoning, generating, analyzing (LLM or script)</td>
                        </tr>
                        <tr>
                            <td><strong data-i18n="table.syntactic">Syntactic</strong></td>
                            <td data-i18n="table.no">âŒ No</td>
                            <td data-i18n="table.free">Free</td>
                            <td data-i18n="table.deterministic">100% Deterministic</td>
                            <td data-i18n="table.syntacticExamples">Collecting, selecting, routing, looping</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            <p data-i18n="section.costNote">A typical 20-step plan might only call an LLM 8 times. Some semantic steps can be optimized to scripts for speed and cost. Syntactic operations are always free: grouping data, selecting values, controlling flow, and iterating.</p>
        </section>

        <!-- Progressive Formalization -->
        <section>
            <h2 data-i18n="section.progressiveTitle">Progressive Formalization</h2>
            <p data-i18n="section.progressiveDesc">NormCode uses a compilation pipeline that progressively transforms rough ideas into executable plans. Each phase adds structure while preserving intentâ€”making complex logic explicit and auditable.</p>
            
            <div class="code-example" style="text-align: center; font-family: 'IBM Plex Mono', monospace;">
                <code data-i18n-html="code.progressivePipeline">
Natural Language Instruction â†’ <em>WHAT</em> and <em>WHY</em><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;â†“<br>
<strong>Phase 1:</strong> Derivation â†’ <em>IN WHAT ORDER</em><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;â†“<br>
<strong>Phase 2:</strong> Formalization â†’ Grammar consistency check<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;â†“<br>
<strong>Phase 3:</strong> Post-Formalization â†’ Contextualization + Resource Demand<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;â†“<br>
<strong>Phase 4:</strong> Activation â†’ Actual Resources + Executables<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;â†“<br>
Orchestrator Executes
                </code>
            </div>
            
            <div class="info-box">
                <p data-i18n="section.progressiveBenefit"><strong>Why this matters:</strong> The instruction defines intent (what and why). Derivation determines execution order. Formalization ensures grammar consistency. Post-formalization adds context and declares resource needs. Activation resolves actual resources and executables. Each stage can be reviewed, so complex logic becomes transparent.</p>
            </div>
        </section>

        <!-- Dive Deeper -->
        <section>
            <h2 data-i18n="section.learnMore">Dive Deeper</h2>
            <p data-i18n="section.learnMoreDesc">Explore the documentation to learn how to write NormCode plans:</p>
            
            <div class="card-grid">
                <a href="docs/syntax.html" class="card-link">
                    <div class="card">
                        <span class="card-icon">ğŸ“</span>
                        <h3 data-i18n="cards.syntax.title">Syntax Reference</h3>
                        <p data-i18n="cards.syntax.desc">Learn the <code class="inline-code">&lt;-</code> and <code class="inline-code">&lt;=</code> markers, concept types, and operators.</p>
                    </div>
                </a>
                
                <a href="docs/execution.html" class="card-link">
                    <div class="card">
                        <span class="card-icon">âš™ï¸</span>
                        <h3 data-i18n="cards.execution.title">Execution Model</h3>
                        <p data-i18n="cards.execution.desc">How plans runâ€”dependency resolution, orchestration, and checkpointing.</p>
                    </div>
                </a>
                
                <a href="docs/compilation.html" class="card-link">
                    <div class="card">
                        <span class="card-icon">ğŸ”„</span>
                        <h3 data-i18n="cards.compilation.title">Compilation</h3>
                        <p data-i18n="cards.compilation.desc">The 4-phase pipeline from natural language to executable JSON repositories.</p>
                    </div>
                </a>
                
                <a href="docs/examples.html" class="card-link">
                    <div class="card">
                        <span class="card-icon">ğŸ’¡</span>
                        <h3 data-i18n="cards.examples.title">Examples</h3>
                        <p data-i18n="cards.examples.desc">Real-world patterns: linear flows, loops, conditionals, and error handling.</p>
                    </div>
                </a>
            </div>
        </section>

        <!-- Core Principles -->
        <section>
            <h2 data-i18n="section.principlesTitle">Core Principles</h2>
            
            <h3 data-i18n="principles.isolation">1. Data Isolation</h3>
            <p data-i18n="principles.isolationDesc">Each step only sees what you explicitly pass to it. No hidden context, no context pollution. If something goes wrong, you can see exactly what that step received.</p>
            
            <h3 data-i18n="principles.auditability">2. Full Auditability</h3>
            <p data-i18n="principles.auditabilityDesc">Inspect what each step saw and produced. Complete state tracking with SQLite checkpointingâ€”pause, resume, or fork from any cycle.</p>
            
            <h3 data-i18n="principles.efficiency">3. Efficient Execution</h3>
            <p data-i18n="principles.efficiencyDesc">Many steps are just data routingâ€”no LLM needed. Only the "thinking" steps cost tokens. Dependency-driven scheduling ensures optimal performance.</p>

            <h3 data-i18n="principles.semiFormal">4. Semi-Formal Balance</h3>
            <p data-i18n="principles.semiFormalDesc">Structured enough for reliable execution, readable enough for human review. AI can generate NormCode, and non-programmers can verify the logic.</p>

            <h3 data-i18n="principles.progressive">5. Progressive Formalization</h3>
            <p data-i18n="principles.progressiveDesc">Start with a rough draft, then incrementally refine. The compiler transforms natural language into explicit structureâ€”each phase answering a specific question while preserving intent.</p>
        </section>

        <!-- When to Use -->
        <section>
            <h2 data-i18n="section.whenTitle">When to Use NormCode</h2>
            
            <div class="table-wrapper">
                <table>
                    <thead>
                        <tr>
                            <th data-i18n="when.scenario">Scenario</th>
                            <th data-i18n="when.use">Use NormCode?</th>
                            <th data-i18n="when.why">Why</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td data-i18n="when.multiStep">Multi-step workflow (5+ LLM calls)</td>
                            <td>âœ… <span data-i18n="when.yes">Yes</span></td>
                            <td data-i18n="when.multiStepWhy">Isolation pays off</td>
                        </tr>
                        <tr>
                            <td data-i18n="when.auditable">Auditable AI (legal, medical, finance)</td>
                            <td>âœ… <span data-i18n="when.yes">Yes</span></td>
                            <td data-i18n="when.auditableWhy">Need proof of reasoning</td>
                        </tr>
                        <tr>
                            <td data-i18n="when.longRunning">Long-running resumable workflows</td>
                            <td>âœ… <span data-i18n="when.yes">Yes</span></td>
                            <td data-i18n="when.longRunningWhy">Built-in checkpointing</td>
                        </tr>
                        <tr>
                            <td data-i18n="when.simple">Simple Q&A chatbot</td>
                            <td>âŒ <span data-i18n="when.no">No</span></td>
                            <td data-i18n="when.simpleWhy">Just prompt directly</td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </section>

        <a href="index.html" class="back-link">
            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M19 12H5M12 19l-7-7 7-7"/>
            </svg>
            <span data-i18n="nav.backHome">Back to Home</span>
        </a>
    </main>

    <!-- Footer -->
    <footer>
        <p><strong>NormCode è§„èŒƒç </strong> Â· <a href="https://github.com/GEOGUANSIN/normCode" target="_blank">GitHub</a> Â· <a href="https://arxiv.org/abs/2512.10563" target="_blank" data-i18n="footer.paper">Paper</a></p>
    </footer>

    <script src="load-nav.js"></script>
    <script>
        const translations = {
            en: {
                nav: {
                    companyName: 'Psylens.AI',
                    home: 'Home',
                    docs: 'Documentation',
                    overview: 'Overview',
                    syntax: 'Syntax Reference',
                    execution: 'Execution Model',
                    compilation: 'Compilation',
                    examples: 'Examples',
                    team: 'Team',
                    backHome: 'Back to Home'
                },
                page: {
                    title: 'How NormCode Works',
                    subtitle: 'A language for structured AI plans that enforce data isolation by design.'
                },
                section: {
                    overview: 'What Problem Does It Solve?',
                    overviewDesc: 'When you chain multiple LLM calls together, context pollution causes failures. By step 4, the model has 50 pages of documents, raw database results, and extraction metadata all swimming in context. It hallucinates because it\'s drowning in noise.',
                    solution: '<strong>The NormCode solution:</strong> Each step is a sealed room. It only sees what you explicitly pass in. No hidden context, no accidental leakage. When something goes wrong, you can see exactly what that step received.',
                    example: 'Example: Document Analysis Pipeline',
                    exampleDesc: 'NormCode uses indentation to show data dependencies. Each step only receives what is explicitly passed to it.',
                    readingNote: '<strong>Reading bottom-up:</strong> The extraction step sees only <code class="inline-code">raw document</code>. The mismatch check sees <code class="inline-code">extracted figures</code> + <code class="inline-code">database results</code>. The summary step sees only <code class="inline-code">discrepancy flags</code>â€”never the full document.',
                    stepsTitle: 'Semantic vs. Syntactic Steps',
                    stepsDesc: 'NormCode distinguishes between two types of operations. Semantic steps <em>may</em> call an LLM, but many can be optimized to use scripts insteadâ€”syntactic steps are always free, instant, and deterministic.',
                    costNote: 'A typical 20-step plan might only call an LLM 8 times. Some semantic steps can be optimized to scripts for speed and cost. Syntactic operations are always free: grouping data, selecting values, controlling flow, and iterating.',
                    progressiveTitle: 'Progressive Formalization',
                    progressiveDesc: 'NormCode uses a compilation pipeline that progressively transforms rough ideas into executable plans. Each phase adds structure while preserving intentâ€”making complex logic explicit and auditable.',
                    progressiveBenefit: '<strong>Why this matters:</strong> The instruction defines intent (what and why). Derivation determines execution order. Formalization ensures grammar consistency. Post-formalization adds context and declares resource needs. Activation resolves actual resources and executables. Each stage can be reviewed, so complex logic becomes transparent.',
                    learnMore: 'Dive Deeper',
                    learnMoreDesc: 'Explore the documentation to learn how to write NormCode plans:',
                    principlesTitle: 'Core Principles',
                    whenTitle: 'When to Use NormCode'
                },
                code: {
                    documentPipeline: '&lt;- executive summary<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;= generate summary from flagged items<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;- discrepancy flags<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;= check for mismatches<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;- extracted figures<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;= extract financial data<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;- raw document<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;- database results',
                    progressivePipeline: 'Natural Language Instruction â†’ <em>WHAT</em> and <em>WHY</em><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;â†“<br><strong>Phase 1:</strong> Derivation â†’ <em>IN WHAT ORDER</em><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;â†“<br><strong>Phase 2:</strong> Formalization â†’ Grammar consistency check<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;â†“<br><strong>Phase 3:</strong> Post-Formalization â†’ Contextualization + Resource Demand<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;â†“<br><strong>Phase 4:</strong> Activation â†’ Actual Resources + Executables<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;â†“<br>Orchestrator Executes'
                },
                table: {
                    type: 'Type',
                    llm: 'LLM?',
                    cost: 'Cost',
                    determinism: 'Determinism',
                    examples: 'Examples',
                    yes: 'âœ… Yes',
                    maybe: 'âš¡ Maybe',
                    no: 'âŒ No',
                    tokens: 'Tokens or Free',
                    free: 'Free',
                    semantic: 'Semantic',
                    syntactic: 'Syntactic',
                    nonDeterministic: 'Varies',
                    deterministic: '100% Deterministic',
                    semanticExamples: 'Reasoning, generating, analyzing (LLM or script)',
                    syntacticExamples: 'Collecting, selecting, routing, looping'
                },
                cards: {
                    syntax: {
                        title: 'Syntax Reference',
                        desc: 'Learn the <- and <= markers, concept types, and operators.'
                    },
                    execution: {
                        title: 'Execution Model',
                        desc: 'How plans runâ€”dependency resolution, orchestration, and checkpointing.'
                    },
                    compilation: {
                        title: 'Compilation',
                        desc: 'The 4-phase pipeline from natural language to executable JSON repositories.'
                    },
                    examples: {
                        title: 'Examples',
                        desc: 'Real-world patterns: linear flows, loops, conditionals, and error handling.'
                    }
                },
                principles: {
                    isolation: '1. Data Isolation',
                    isolationDesc: 'Each step only sees what you explicitly pass to it. No hidden context, no context pollution. If something goes wrong, you can see exactly what that step received.',
                    auditability: '2. Full Auditability',
                    auditabilityDesc: 'Inspect what each step saw and produced. Complete state tracking with SQLite checkpointingâ€”pause, resume, or fork from any cycle.',
                    efficiency: '3. Efficient Execution',
                    efficiencyDesc: 'Many steps are just data routingâ€”no LLM needed. Only the "thinking" steps cost tokens. Dependency-driven scheduling ensures optimal performance.',
                    semiFormal: '4. Semi-Formal Balance',
                    semiFormalDesc: 'Structured enough for reliable execution, readable enough for human review. AI can generate NormCode, and non-programmers can verify the logic.',
                    progressive: '5. Progressive Formalization',
                    progressiveDesc: 'Start with a rough draft, then incrementally refine. The compiler transforms natural language into explicit structureâ€”each phase answering a specific question while preserving intent.'
                },
                when: {
                    scenario: 'Scenario',
                    use: 'Use NormCode?',
                    why: 'Why',
                    multiStep: 'Multi-step workflow (5+ LLM calls)',
                    yes: 'Yes',
                    no: 'No',
                    multiStepWhy: 'Isolation pays off',
                    auditable: 'Auditable AI (legal, medical, finance)',
                    auditableWhy: 'Need proof of reasoning',
                    longRunning: 'Long-running resumable workflows',
                    longRunningWhy: 'Built-in checkpointing',
                    simple: 'Simple Q&A chatbot',
                    simpleWhy: 'Just prompt directly'
                },
                footer: {
                    paper: 'Paper'
                }
            },
            zh: {
                nav: {
                    companyName: 'å¿ƒé•œæ™º',
                    home: 'é¦–é¡µ',
                    docs: 'æ–‡æ¡£',
                    overview: 'æ¦‚è¿°',
                    syntax: 'è¯­æ³•å‚è€ƒ',
                    execution: 'æ‰§è¡Œæ¨¡å‹',
                    compilation: 'ç¼–è¯‘æµç¨‹',
                    examples: 'ç¤ºä¾‹',
                    team: 'å›¢é˜Ÿ',
                    backHome: 'è¿”å›é¦–é¡µ'
                },
                page: {
                    title: 'NormCode å·¥ä½œåŸç†',
                    subtitle: 'ä¸€ç§é€šè¿‡è®¾è®¡å¼ºåˆ¶æ•°æ®éš”ç¦»çš„ç»“æ„åŒ–AIè§„åˆ’è¯­è¨€ã€‚'
                },
                section: {
                    overview: 'å®ƒè§£å†³ä»€ä¹ˆé—®é¢˜ï¼Ÿ',
                    overviewDesc: 'å½“æ‚¨é“¾æ¥å¤šä¸ªLLMè°ƒç”¨æ—¶ï¼Œä¸Šä¸‹æ–‡æ±¡æŸ“ä¼šå¯¼è‡´å¤±è´¥ã€‚åˆ°ç¬¬4æ­¥æ—¶ï¼Œæ¨¡å‹å·²ç»è¢«50é¡µæ–‡æ¡£ã€åŸå§‹æ•°æ®åº“ç»“æœå’Œæå–å…ƒæ•°æ®æ·¹æ²¡ã€‚å®ƒäº§ç”Ÿå¹»è§‰ï¼Œå› ä¸ºå®ƒè¢«å™ªéŸ³æ·¹æ²¡äº†ã€‚',
                    solution: '<strong>NormCodeè§£å†³æ–¹æ¡ˆï¼š</strong>æ¯ä¸ªæ­¥éª¤éƒ½æ˜¯ä¸€ä¸ªå¯†å°çš„æˆ¿é—´ã€‚å®ƒåªèƒ½çœ‹åˆ°æ‚¨æ˜ç¡®ä¼ é€’çš„å†…å®¹ã€‚æ²¡æœ‰éšè—ä¸Šä¸‹æ–‡ï¼Œæ²¡æœ‰æ„å¤–æ³„æ¼ã€‚å½“å‡ºç°é—®é¢˜æ—¶ï¼Œæ‚¨å¯ä»¥å‡†ç¡®çœ‹åˆ°è¯¥æ­¥éª¤æ¥æ”¶åˆ°çš„å†…å®¹ã€‚',
                    example: 'ç¤ºä¾‹ï¼šæ–‡æ¡£åˆ†ææµæ°´çº¿',
                    exampleDesc: 'NormCodeä½¿ç”¨ç¼©è¿›æ¥æ˜¾ç¤ºæ•°æ®ä¾èµ–å…³ç³»ã€‚æ¯ä¸ªæ­¥éª¤åªæ¥æ”¶æ˜¾å¼ä¼ é€’ç»™å®ƒçš„å†…å®¹ã€‚',
                    readingNote: '<strong>è‡ªä¸‹è€Œä¸Šé˜…è¯»ï¼š</strong>æå–æ­¥éª¤åªèƒ½çœ‹åˆ°<code class="inline-code">åŸå§‹æ–‡æ¡£</code>ã€‚ä¸åŒ¹é…æ£€æŸ¥çœ‹åˆ°<code class="inline-code">æå–çš„æ•°å€¼</code> + <code class="inline-code">æ•°æ®åº“ç»“æœ</code>ã€‚æ‘˜è¦æ­¥éª¤åªèƒ½çœ‹åˆ°<code class="inline-code">å·®å¼‚æ ‡å¿—</code>â€”â€”æ°¸è¿œçœ‹ä¸åˆ°å®Œæ•´æ–‡æ¡£ã€‚',
                    stepsTitle: 'è¯­ä¹‰æ­¥éª¤ vs. è¯­æ³•æ­¥éª¤',
                    stepsDesc: 'NormCodeåŒºåˆ†ä¸¤ç§ç±»å‹çš„æ“ä½œã€‚è¯­ä¹‰æ­¥éª¤<em>å¯èƒ½</em>è°ƒç”¨LLMï¼Œä½†è®¸å¤šå¯ä»¥ä¼˜åŒ–ä¸ºä½¿ç”¨è„šæœ¬â€”â€”è¯­æ³•æ­¥éª¤å§‹ç»ˆæ˜¯å…è´¹çš„ã€å³æ—¶çš„å’Œç¡®å®šæ€§çš„ã€‚',
                    costNote: 'ä¸€ä¸ªå…¸å‹çš„20æ­¥è®¡åˆ’å¯èƒ½åªè°ƒç”¨LLM 8æ¬¡ã€‚ä¸€äº›è¯­ä¹‰æ­¥éª¤å¯ä»¥ä¼˜åŒ–ä¸ºè„šæœ¬ä»¥æé«˜é€Ÿåº¦å’Œé™ä½æˆæœ¬ã€‚è¯­æ³•æ“ä½œå§‹ç»ˆå…è´¹ï¼šåˆ†ç»„æ•°æ®ã€é€‰æ‹©å€¼ã€æ§åˆ¶æµç¨‹å’Œè¿­ä»£ã€‚',
                    progressiveTitle: 'æ¸è¿›å¼å½¢å¼åŒ–',
                    progressiveDesc: 'NormCodeä½¿ç”¨ç¼–è¯‘æµæ°´çº¿ï¼Œå°†ç²—ç•¥çš„æƒ³æ³•é€æ­¥è½¬åŒ–ä¸ºå¯æ‰§è¡Œçš„è®¡åˆ’ã€‚æ¯ä¸ªé˜¶æ®µéƒ½åœ¨ä¿ç•™æ„å›¾çš„åŒæ—¶å¢åŠ ç»“æ„â€”â€”ä½¿å¤æ‚é€»è¾‘å˜å¾—æ¸…æ™°å¯å®¡è®¡ã€‚',
                    progressiveBenefit: '<strong>ä¸ºä»€ä¹ˆé‡è¦ï¼š</strong>æŒ‡ä»¤å®šä¹‰æ„å›¾ï¼ˆåšä»€ä¹ˆå’Œä¸ºä»€ä¹ˆï¼‰ã€‚æ¨å¯¼ç¡®å®šæ‰§è¡Œé¡ºåºã€‚å½¢å¼åŒ–ç¡®ä¿è¯­æ³•ä¸€è‡´æ€§ã€‚åå½¢å¼åŒ–æ·»åŠ ä¸Šä¸‹æ–‡å¹¶å£°æ˜èµ„æºéœ€æ±‚ã€‚æ¿€æ´»è§£æå®é™…èµ„æºå’Œå¯æ‰§è¡Œæ–‡ä»¶ã€‚æ¯ä¸ªé˜¶æ®µéƒ½å¯ä»¥å®¡æŸ¥ï¼Œä½¿å¤æ‚é€»è¾‘å˜å¾—é€æ˜ã€‚',
                    learnMore: 'æ·±å…¥äº†è§£',
                    learnMoreDesc: 'æ¢ç´¢æ–‡æ¡£ä»¥å­¦ä¹ å¦‚ä½•ç¼–å†™NormCodeè®¡åˆ’ï¼š',
                    principlesTitle: 'æ ¸å¿ƒåŸåˆ™',
                    whenTitle: 'ä½•æ—¶ä½¿ç”¨NormCode'
                },
                table: {
                    type: 'ç±»å‹',
                    llm: 'éœ€è¦LLMï¼Ÿ',
                    cost: 'æˆæœ¬',
                    determinism: 'ç¡®å®šæ€§',
                    examples: 'ç¤ºä¾‹',
                    yes: 'âœ… æ˜¯',
                    maybe: 'âš¡ å¯èƒ½',
                    no: 'âŒ å¦',
                    tokens: 'Tokenæˆ–å…è´¹',
                    free: 'å…è´¹',
                    semantic: 'è¯­ä¹‰',
                    syntactic: 'è¯­æ³•',
                    nonDeterministic: 'å¯å˜',
                    deterministic: '100% ç¡®å®šæ€§',
                    semanticExamples: 'æ¨ç†ã€ç”Ÿæˆã€åˆ†æï¼ˆLLMæˆ–è„šæœ¬ï¼‰',
                    syntacticExamples: 'æ”¶é›†ã€é€‰æ‹©ã€è·¯ç”±ã€å¾ªç¯'
                },
                code: {
                    documentPipeline: '&lt;- æ‰§è¡Œæ‘˜è¦<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;= æ ¹æ®æ ‡è®°é¡¹ç”Ÿæˆæ‘˜è¦<br>&nbsp;&nbsp;&nbsp;&nbsp;&lt;- å·®å¼‚æ ‡è®°<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;= æ£€æŸ¥ä¸åŒ¹é…é¡¹<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;- æå–çš„æ•°æ®<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;= æå–è´¢åŠ¡æ•°æ®<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;- åŸå§‹æ–‡æ¡£<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;- æ•°æ®åº“ç»“æœ',
                    progressivePipeline: 'è‡ªç„¶è¯­è¨€æŒ‡ä»¤ â†’ <em>åšä»€ä¹ˆ</em>å’Œ<em>ä¸ºä»€ä¹ˆ</em><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;â†“<br><strong>é˜¶æ®µ1ï¼š</strong>æ¨å¯¼ â†’ <em>ä»€ä¹ˆé¡ºåº</em><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;â†“<br><strong>é˜¶æ®µ2ï¼š</strong>å½¢å¼åŒ– â†’ è¯­æ³•ä¸€è‡´æ€§æ£€æŸ¥<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;â†“<br><strong>é˜¶æ®µ3ï¼š</strong>åå½¢å¼åŒ– â†’ ä¸Šä¸‹æ–‡åŒ– + èµ„æºéœ€æ±‚<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;â†“<br><strong>é˜¶æ®µ4ï¼š</strong>æ¿€æ´» â†’ å®é™…èµ„æº + å¯æ‰§è¡Œæ–‡ä»¶<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;â†“<br>ç¼–æ’å™¨æ‰§è¡Œ'
                },
                cards: {
                    syntax: {
                        title: 'è¯­æ³•å‚è€ƒ',
                        desc: 'å­¦ä¹  <- å’Œ <= æ ‡è®°ã€æ¦‚å¿µç±»å‹å’Œæ“ä½œç¬¦ã€‚'
                    },
                    execution: {
                        title: 'æ‰§è¡Œæ¨¡å‹',
                        desc: 'è®¡åˆ’å¦‚ä½•è¿è¡Œâ€”â€”ä¾èµ–è§£æã€ç¼–æ’å’Œæ£€æŸ¥ç‚¹ã€‚'
                    },
                    compilation: {
                        title: 'ç¼–è¯‘æµç¨‹',
                        desc: 'ä»è‡ªç„¶è¯­è¨€åˆ°å¯æ‰§è¡ŒJSONå­˜å‚¨åº“çš„4é˜¶æ®µæµæ°´çº¿ã€‚'
                    },
                    examples: {
                        title: 'ç¤ºä¾‹',
                        desc: 'å®é™…æ¨¡å¼ï¼šçº¿æ€§æµç¨‹ã€å¾ªç¯ã€æ¡ä»¶å’Œé”™è¯¯å¤„ç†ã€‚'
                    }
                },
                principles: {
                    isolation: '1. æ•°æ®éš”ç¦»',
                    isolationDesc: 'æ¯ä¸ªæ­¥éª¤åªèƒ½çœ‹åˆ°æ‚¨æ˜ç¡®ä¼ é€’ç»™å®ƒçš„å†…å®¹ã€‚æ²¡æœ‰éšè—çš„ä¸Šä¸‹æ–‡ï¼Œæ²¡æœ‰ä¸Šä¸‹æ–‡æ±¡æŸ“ã€‚å¦‚æœå‡ºç°é—®é¢˜ï¼Œæ‚¨å¯ä»¥å‡†ç¡®çœ‹åˆ°è¯¥æ­¥éª¤æ¥æ”¶çš„å†…å®¹ã€‚',
                    auditability: '2. å®Œå…¨å¯å®¡è®¡',
                    auditabilityDesc: 'æ£€æŸ¥æ¯ä¸ªæ­¥éª¤çœ‹åˆ°å’Œäº§ç”Ÿçš„å†…å®¹ã€‚å®Œæ•´çš„çŠ¶æ€è·Ÿè¸ªï¼Œæ”¯æŒSQLiteæ£€æŸ¥ç‚¹â€”â€”å¯ä»¥ä»ä»»ä½•å‘¨æœŸæš‚åœã€æ¢å¤æˆ–åˆ†å‰ã€‚',
                    efficiency: '3. é«˜æ•ˆæ‰§è¡Œ',
                    efficiencyDesc: 'è®¸å¤šæ­¥éª¤åªæ˜¯æ•°æ®è·¯ç”±â€”â€”ä¸éœ€è¦LLMã€‚åªæœ‰"æ€è€ƒ"æ­¥éª¤éœ€è¦æ¶ˆè€—tokenã€‚ä¾èµ–é©±åŠ¨çš„è°ƒåº¦ç¡®ä¿æœ€ä½³æ€§èƒ½ã€‚',
                    semiFormal: '4. åŠå½¢å¼åŒ–å¹³è¡¡',
                    semiFormalDesc: 'ç»“æ„åŒ–ç¨‹åº¦è¶³ä»¥å¯é æ‰§è¡Œï¼Œå¯è¯»æ€§è¶³ä»¥ä¾›äººå·¥å®¡æŸ¥ã€‚AIå¯ä»¥ç”ŸæˆNormCodeï¼Œéç¨‹åºå‘˜å¯ä»¥éªŒè¯é€»è¾‘ã€‚',
                    progressive: '5. æ¸è¿›å¼å½¢å¼åŒ–',
                    progressiveDesc: 'ä»ç²—ç•¥è‰ç¨¿å¼€å§‹ï¼Œé€æ­¥å®Œå–„ã€‚ç¼–è¯‘å™¨å°†è‡ªç„¶è¯­è¨€è½¬åŒ–ä¸ºæ˜ç¡®ç»“æ„â€”â€”æ¯ä¸ªé˜¶æ®µå›ç­”ç‰¹å®šé—®é¢˜ï¼ŒåŒæ—¶ä¿ç•™æ„å›¾ã€‚'
                },
                when: {
                    scenario: 'åœºæ™¯',
                    use: 'ä½¿ç”¨NormCodeï¼Ÿ',
                    why: 'åŸå› ',
                    multiStep: 'å¤šæ­¥éª¤å·¥ä½œæµï¼ˆ5+ LLMè°ƒç”¨ï¼‰',
                    yes: 'æ˜¯',
                    no: 'å¦',
                    multiStepWhy: 'éš”ç¦»å¸¦æ¥å›æŠ¥',
                    auditable: 'å¯å®¡è®¡AIï¼ˆæ³•å¾‹ã€åŒ»ç–—ã€é‡‘èï¼‰',
                    auditableWhy: 'éœ€è¦æ¨ç†è¯æ˜',
                    longRunning: 'é•¿æ—¶é—´è¿è¡Œçš„å¯æ¢å¤å·¥ä½œæµ',
                    longRunningWhy: 'å†…ç½®æ£€æŸ¥ç‚¹',
                    simple: 'ç®€å•çš„é—®ç­”èŠå¤©æœºå™¨äºº',
                    simpleWhy: 'ç›´æ¥æç¤ºå³å¯'
                },
                footer: {
                    paper: 'è®ºæ–‡'
                }
            }
        };

        let currentLang = localStorage.getItem('lang') || 'en';

        // Expose setLanguage globally so load-nav.js can call it
        window.setLanguage = function(lang) {
            currentLang = lang;
            localStorage.setItem('lang', lang);
            document.documentElement.lang = lang;
            
            document.querySelectorAll('[data-i18n]').forEach(el => {
                const key = el.getAttribute('data-i18n');
                const keys = key.split('.');
                let value = translations[lang];
                
                for (const k of keys) {
                    value = value?.[k];
                }
                
                if (value !== undefined) {
                    if (value.includes('<code') || value.includes('<strong')) {
                        el.innerHTML = value;
                    } else {
                        el.textContent = value;
                    }
                }
            });

            // Handle HTML translations (for code examples)
            document.querySelectorAll('[data-i18n-html]').forEach(el => {
                const key = el.getAttribute('data-i18n-html');
                const keys = key.split('.');
                let value = translations[lang];
                
                for (const k of keys) {
                    value = value?.[k];
                }
                
                if (value !== undefined) {
                    el.innerHTML = value;
                }
            });

            document.querySelectorAll('.lang-btn').forEach(btn => {
                btn.classList.toggle('active', btn.getAttribute('data-lang') === lang);
            });
        };
        
        setLanguage(currentLang);

        document.querySelectorAll('.lang-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                setLanguage(btn.getAttribute('data-lang'));
            });
        });

        // Mobile menu is handled by load-nav.js
    </script>
</body>
</html>
